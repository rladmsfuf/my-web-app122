<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>이미지 비율 변환 + 워터마크</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: #f5f5f5;
      padding: 20px;
    }
    .container { 
      max-width: 1000px; 
      margin: 0 auto; 
      background: white; 
      border-radius: 12px; 
      padding: 30px; 
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    }
    h1 { 
      text-align: center; 
      color: #333; 
      margin-bottom: 30px; 
      font-size: 2rem;
    }
    .upload-section {
      border: 3px dashed #007bff;
      border-radius: 12px;
      padding: 40px;
      text-align: center;
      margin-bottom: 30px;
      background: #f8f9ff;
    }
    .ratio-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }
    .ratio-btn {
      padding: 12px 24px;
      border: 2px solid #007bff;
      background: white;
      color: #007bff;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
    }
    .ratio-btn.active {
      background: #007bff;
      color: white;
    }
    .watermark-section {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 30px;
    }
    .watermark-toggle {
      display: flex;
      align-items: center;
      gap: 12px;
      margin-bottom: 15px;
      font-weight: 600;
    }
    .watermark-toggle input {
      width: 20px;
      height: 20px;
      accent-color: #007bff;
    }
    .watermark-options {
      display: block;
      padding-left: 32px;
    }
    .watermark-option {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-bottom: 12px;
    }
    .watermark-option label {
      min-width: 80px;
      font-weight: 500;
    }
    .control-buttons {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    .btn {
      padding: 12px 24px;
      border: none;
      border-radius: 8px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s;
    }
    .btn-primary { background: #007bff; color: white; }
    .btn-secondary { background: #6c757d; color: white; }
    .btn-success { background: #28a745; color: white; }
    .btn:disabled { opacity: 0.6; cursor: not-allowed; }
    .status {
      text-align: center;
      margin-bottom: 20px;
      font-weight: 500;
      color: #666;
    }
    .preview-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 20px;
      margin-top: 20px;
    }
    .preview-card {
      border: 1px solid #ddd;
      border-radius: 8px;
      padding: 15px;
      text-align: center;
      background: white;
    }
    .preview-card h4 {
      margin-bottom: 10px;
      font-size: 0.9rem;
      color: #333;
    }
    .preview-canvas {
      max-width: 100%;
      border-radius: 6px;
      margin-bottom: 10px;
    }
    .download-btn {
      width: 100%;
      padding: 8px 16px;
      background: #28a745;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    #fileInput { display: none; }
  </style>
</head>
<body>
  <div class="container">
    <h1>이미지 비율 변환 + 워터마크</h1>
    <div class="upload-section" onclick="document.getElementById('fileInput').click()">
      <input type="file" id="fileInput" accept="image/*" multiple>
      <h3>📸 이미지 파일 선택</h3>
      <p>클릭하거나 파일을 드래그해서 업로드하세요</p>
      <p style="color: #666; font-size: 0.9rem;">최대 500장까지 지원</p>
    </div>
    <div class="ratio-buttons">
      <button class="ratio-btn active" data-ratio="16:9">16:9 와이드</button>
      <button class="ratio-btn" data-ratio="4:3">4:3 일반</button>
      <button class="ratio-btn" data-ratio="1:1">1:1 정사각</button>
      <button class="ratio-btn" data-ratio="3:4">3:4 세로</button>
    </div>
    <div class="watermark-section">
      <div class="watermark-toggle">
        <input type="checkbox" id="watermarkEnabled" checked>
        <label for="watermarkEnabled">워터마크 추가 (Free Care 로고)</label>
      </div>
    </div>
    <div class="control-buttons">
      <button class="btn btn-primary" id="processBtn" disabled>🚀 이미지 처리</button>
      <button class="btn btn-secondary" id="clearBtn">🗑 초기화</button>
      <button class="btn btn-success" id="zipBtn" disabled>📦 ZIP 다운로드</button>
    </div>
    <div class="status" id="status">이미지를 선택해주세요</div>
    <div class="preview-grid" id="previewGrid"></div>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    // 전역 변수
    let selectedFiles = [];
    let processedImages = [];
    let selectedRatio = '16:9';
    // DOM 요소들
    const fileInput = document.getElementById('fileInput');
    const uploadSection = document.querySelector('.upload-section');
    const ratioButtons = document.querySelectorAll('.ratio-btn');
    const watermarkEnabled = document.getElementById('watermarkEnabled');
    const processBtn = document.getElementById('processBtn');
    const clearBtn = document.getElementById('clearBtn');
    const zipBtn = document.getElementById('zipBtn');
    const status = document.getElementById('status');
    const previewGrid = document.getElementById('previewGrid');

    // 메시지 표시 함수 (alert 대신 사용)
    function showMessage(msg) {
        status.textContent = msg;
        setTimeout(updateStatus, 5000); // 5초 후 원래 상태로 돌아감
    }

    // 이벤트 리스너들
    fileInput.addEventListener('change', handleFileSelect);
    uploadSection.addEventListener('dragover', handleDragOver);
    uploadSection.addEventListener('drop', handleDrop);
    processBtn.addEventListener('click', processImages);
    clearBtn.addEventListener('click', clearAll);
    zipBtn.addEventListener('click', downloadZip);
    // 비율 버튼 이벤트
    ratioButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        ratioButtons.forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        selectedRatio = btn.dataset.ratio;
      });
    });
    // 함수들
    function handleFileSelect(e) {
      const files = Array.from(e.target.files);
      processFileSelection(files);
    }
    function handleDragOver(e) {
      e.preventDefault();
      uploadSection.style.background = '#e3f2fd';
    }
    function handleDrop(e) {
      e.preventDefault();
      uploadSection.style.background = '#f8f9ff';
      const files = Array.from(e.dataTransfer.files).filter(file => file.type.startsWith('image/'));
      processFileSelection(files);
    }
    function processFileSelection(files) {
      if (files.length > 500) {
        showMessage('최대 500장까지 업로드 가능합니다.');
        selectedFiles = files.slice(0, 500);
      } else {
        selectedFiles = files;
      }
      updateStatus();
      showOriginalPreviews();
    }
    function updateStatus() {
      const fileCount = selectedFiles.length;
      const processedCount = processedImages.length;
      if (fileCount === 0) {
        status.textContent = '이미지를 선택해주세요';
      } else if (processedCount === 0) {
        status.textContent = `${fileCount}개 이미지 선택됨 - 처리 대기 중`;
      } else {
        status.textContent = `${processedCount}개 이미지 처리 완료`;
      }
      processBtn.disabled = fileCount === 0;
      zipBtn.disabled = processedCount === 0;
    }
    function showOriginalPreviews() {
      previewGrid.innerHTML = '';
      selectedFiles.slice(0, 12).forEach((file, index) => {
        const reader = new FileReader();
        reader.onload = function(e) {
          const img = new Image();
          img.onload = function() {
            const card = document.createElement('div');
            card.className = 'preview-card';
            const title = document.createElement('h4');
            title.textContent = `${file.name} (원본)`;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const maxSize = 200;
            const scale = Math.min(maxSize / img.width, maxSize / img.height);
            canvas.width = img.width * scale;
            canvas.height = img.height * scale;
            canvas.className = 'preview-canvas';
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            card.appendChild(title);
            card.appendChild(canvas);
            previewGrid.appendChild(card);
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      });
    }
    function getRatioValue(ratioStr) {
      const [w, h] = ratioStr.split(':').map(Number);
      return w / h;
    }
    function addWatermark(canvas, ctx) {
      if (!watermarkEnabled.checked) return;
      // 'Free'와 'Care' 두 줄로 워터마크를 사용합니다.
      const line1 = 'Free';
      const line2 = 'Care';
      const opacity = 1;
      
      // 글자 크기를 이미지 너비에 따라 동적으로 설정
      const fontSize = Math.min(canvas.width, canvas.height) * 0.04;
      ctx.font = `bold ${fontSize}px Arial`;

      // 텍스트 측정
      const textMetrics1 = ctx.measureText(line1);
      const textMetrics2 = ctx.measureText(line2);
      const maxWidth = Math.max(textMetrics1.width, textMetrics2.width);
      
      const margin = 3; // 여백을 줄여서 워터마크를 오른쪽으로 이동
      const padding = 10; // 패딩을 늘려서 워터마크 크기를 키움
      const lineHeight = fontSize * 1.2; // 줄 간격
      
      // 전체 워터마크 영역의 크기 계산
      const bgWidth = maxWidth + padding * 2;
      const bgHeight = (lineHeight * 2) + padding * 2;
      
      // 위치 계산
      const bgX = canvas.width - bgWidth - margin;
      const bgY = canvas.height - bgHeight - margin;
      
      ctx.save();
      ctx.globalAlpha = opacity;
      
      // 배경 사각형 그리기 (완전 불투명한 검은색)
      ctx.fillStyle = 'rgba(0, 0, 0, 1)';
      ctx.fillRect(bgX, bgY, bgWidth, bgHeight);
      
      // 그림자 효과 추가
      ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
      ctx.shadowOffsetX = 2;
      ctx.shadowOffsetY = 2;
      ctx.shadowBlur = 4;
      
      // 텍스트 그리기 (왼쪽 정렬, 흰색)
      ctx.fillStyle = 'white';
      ctx.textBaseline = 'top';
      ctx.fillText(line1, bgX + padding, bgY + padding);
      ctx.fillText(line2, bgX + padding, bgY + padding + lineHeight);

      ctx.restore();
    }
    function processImages() {
      if (selectedFiles.length === 0) return;
      processedImages = [];
      previewGrid.innerHTML = '';
      const targetRatio = getRatioValue(selectedRatio);
      let completed = 0;
      status.textContent = `처리 중... (0/${selectedFiles.length})`;
      selectedFiles.forEach((file, index) => {
        const reader = new FileReader();
        reader.onload = function(e) {
          const img = new Image();
          img.onload = function() {
            // 비율에 맞게 크롭
            let w = img.width, h = img.height;
            let sw, sh, sx, sy;
            if (w / h > targetRatio) {
              sh = h;
              sw = h * targetRatio;
              sx = (w - sw) / 2;
              sy = 0;
            } else {
              sw = w;
              sh = w / targetRatio;
              sx = 0;
              sy = (h - sh) / 2;
            }
            const canvas = document.createElement('canvas');
            canvas.width = sw;
            canvas.height = sh;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, sx, sy, sw, sh, 0, 0, sw, sh);
            // 워터마크 추가
            addWatermark(canvas, ctx);
            // 결과 저장
            const dataURL = canvas.toDataURL('image/jpeg', 0.92);
            const fileName = `${file.name.split('.')[0]}_${selectedRatio.replace(':', 'x')}.jpg`;
            processedImages.push({ dataURL, fileName, canvas });
            // 미리보기 카드 생성
            const card = document.createElement('div');
            card.className = 'preview-card';
            const title = document.createElement('h4');
            title.textContent = `${fileName}`;
            const previewCanvas = document.createElement('canvas');
            const previewCtx = previewCanvas.getContext('2d');
            const maxSize = 200;
            const scale = Math.min(maxSize / canvas.width, maxSize / canvas.height);
            previewCanvas.width = canvas.width * scale;
            previewCanvas.height = canvas.height * scale;
            previewCanvas.className = 'preview-canvas';
            previewCtx.drawImage(canvas, 0, 0, previewCanvas.width, previewCanvas.height);
            const downloadBtn = document.createElement('button');
            downloadBtn.className = 'download-btn';
            downloadBtn.textContent = '개별 다운로드';
            downloadBtn.onclick = () => {
              const a = document.createElement('a');
              a.href = dataURL;
              a.download = fileName;
              a.click();
            };
            card.appendChild(title);
            card.appendChild(previewCanvas);
            card.appendChild(downloadBtn);
            previewGrid.appendChild(card);
            // 진행 상황 업데이트
            completed++;
            status.textContent = `처리 중... (${completed}/${selectedFiles.length})`;
            if (completed === selectedFiles.length) {
              updateStatus();
            }
          };
          img.src = e.target.result;
        };
        reader.readAsDataURL(file);
      });
    }
    function clearAll() {
      selectedFiles = [];
      processedImages = [];
      fileInput.value = '';
      previewGrid.innerHTML = '';
      updateStatus();
    }
    async function downloadZip() {
      if (processedImages.length === 0) {
        showMessage('처리된 이미지가 없습니다.');
        return;
      }
      try {
        status.textContent = 'ZIP 파일 생성 중...';
        const zip = new JSZip();
        const folder = zip.folder(`images_${selectedRatio.replace(':', 'x')}`);
        // 각 이미지를 ZIP에 추가
        for (let i = 0; i < processedImages.length; i++) {
          const img = processedImages[i];
          try {
            // Canvas를 Blob으로 변환
            const blob = await new Promise(resolve => {
              img.canvas.toBlob(resolve, 'image/jpeg', 0.92);
            });
            if (blob) {
              folder.file(img.fileName, blob);
            } else {
              // Blob 생성 실패 시 DataURL 사용
              const base64Data = img.dataURL.split(',')[1];
              folder.file(img.fileName, base64Data, { base64: true });
            }
          } catch (error) {
            console.error(`이미지 ${i} 처리 오류:`, error);
            // 오류가 있어도 계속 진행
            const base64Data = img.dataURL.split(',')[1];
            folder.file(img.fileName, base64Data, { base64: true });
          }
        }
        const content = await zip.generateAsync({
           type: 'blob',
          compression: 'DEFLATE',
          compressionOptions: { level: 6 }
        });
        // 다운로드 실행
        const url = URL.createObjectURL(content);
        const a = document.createElement('a');
        a.href = url;
        a.download = `processed_images_${selectedRatio.replace(':', 'x')}_${processedImages.length}장.zip`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        status.textContent = `ZIP 다운로드 완료! (${processedImages.length}장)`;
      } catch (error) {
        console.error('ZIP 생성 오류:', error);
        showMessage(`ZIP 생성 중 오류가 발생했습니다: ${error.message}`);
        updateStatus();
      }
    }
    // 초기화
    updateStatus();
  </script>
</body>
</html>
